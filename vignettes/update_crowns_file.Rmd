---
title: "update_crowns_file"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{update_crowns_file}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, 	message = FALSE, warning = FALSE, results = "hide"}

library(SHPcrownsfile)
library(sf)
library(tidyverse)
library(readxl)
library(mapview)
```

```{r, message=FALSE, warning=FALSE, paged.print=FALSE, results = 'hide'}
old_shp <- read_sf(system.file("gpkg/old_version.gpkg", package = 'SHPcrownsfile'))
new_shp <- read_sf(system.file("gpkg/gpkg_from_tablet.gpkg", package = 'SHPcrownsfile'))

# Le crs doit être en UTM
new_shp_corrected <- get_correct_id(new_shp = new_shp, 
               old_shp = old_shp, 
               crs = 'epsg:32633')
```

STEP 1 : Regarder les polygones dont la geometrie a été modifiée et l'id a été 
retrouvé dans l'ancien fichier à partir de id_n. Typiquement un arbre mal dessiné

--- Est ce que l'id a bien suivi ? 
--- Est ce qu'on changer l'id car on considère qu'il ne s'agit plus du même arbre ?
(Typiquement quand la couronne a été délimité sur le mauvais arbre et qu'à partir 
de l'identification Alex a corriger la geometrie sur la mission m+1 pour remettre sur 
le bon arbre. Dans ce cas, l'id doit changer et la geometrie de l'autre arbre doit 
rester dans le nouveau fichier, si elle était bien délimité (et surtout si des traits 
ont été collectés dessus), veiller à changer l'identification)

```{r, message=FALSE, warning=FALSE, paged.print=FALSE, results = 'hide'}
modif_geom_new  = new_shp_corrected$corrected_shp %>% filter(
   id %in% new_shp_corrected$no_match_found_by_geom,
   idmodif_idn == 'OUI')

modif_geom_old = old_shp[old_shp$id %in% modif_geom_new$id,]

mapview(old_shp,alpha.regions = 0,lwd = 0.5,color = 'black',label = modif_geom_old$id) +
   mapview(modif_geom_old,col.regions = "blue",alpha.regions = 0.5,lwd = 2,color ='blue',label = modif_geom_old$id) +
   mapview(modif_geom_new,col.regions = "red",alpha.regions = 0.2,lwd = 2,color = 'red',label = modif_geom_new$id)
```

STEP 2 : Regarder les nouvelles couronnes

Ici il faut simplment s'assurer que les nouvelles couronnes ne correspondent pas 
aux anciennes et que Qfield a bien généré des ids non existants


```{r, message=FALSE, warning=FALSE, paged.print=FALSE, results = 'hide'}
new_crowns  = new_shp_corrected$corrected_shp %>% filter(
    id %in% new_shp_corrected$no_match_found_by_geom,
    is.na(idmodif_idn))

# Check, si Qfield n'a pas généré des ids déjà existants (normalement non)
new_crowns$id[new_crowns$id %in% old_shp$id]

# Check, si les couronnes rouge ne correspondent à aucune couronne noire, si c'est le 
# il faudra lui reatribuer le bon id
mapview(old_shp,alpha.regions = 0,lwd = 0.5,color = 'black',label = modif_geom_old$id) +
   mapview(new_crowns,col.regions = "red",alpha.regions = 0.2,lwd = 2,color = 'red',label = modif_geom_new$id)
```



STEP 3 : Regarder si des couronnes ont été supprimées

Si oui, suppression volontaire et justifiée ? ne rien faire
Si oui, suppression non justifiée ? Remettre la couronne dans le nouveau fichier
Si non, RAS

```{r, message=FALSE, warning=FALSE, paged.print=FALSE, results = 'hide'}
old_shp$id[!old_shp$id %in% new_shp_corrected$corrected_shp$id] 
```


STEP 3 : Regarder si il n'y a pas d'id dupliqué

```{r, message=FALSE, warning=FALSE, paged.print=FALSE, results = 'hide'}
new_shp_corrected$corrected_shp$id[duplicated(new_shp_corrected$corrected_shp$id)]
```
MANIP DE GILLES, ET ON CONTINUE...

```{r}
gil <- read_xlsx(system.file("xlsx/extract_bouamir_observatory_10_2024.xlsx", package = 'SHPcrownsfile'))
sf <- new_shp_corrected$corrected_shp
# Check les ids manquants
sf$id[!sf$id %in% gil$id]
gil$id[!gil$id %in% sf$id] # ajouter l'id 984 depuis dbx


sf <- sf %>% filter(id %in% gil$id)

sf <- sf %>% arrange(id)
gil <- gil %>% arrange(id)
gil_984 <- gil %>% filter(id == 984)
gil <- gil %>% filter(id != 984)
unique(sf$id == gil$id)


sf <- sf %>% mutate(id_n = gil$id_n,
              tx_sp_lvl = gil$tax_sp_level,
              tax_gen = gil$tax_gen,
              tax_fam = gil$tax_fam,
              idtax_f = gil$idtax_f,
              wood_density_mean = gil$wood_density_mean)


sf <- sf %>% select(-c(idmodif_idn,idmodif_geom))


# ajouter l'id 984 depuis dbx
# old_sf <- read_sf(file.choose())
# old_sf <- old_sf %>% filter(id == 984)
# old_sf <- old_sf %>% select(-area)
# old_sf <- old_sf %>% select(-c(taxa_level_succession_guild,stem_diameter_observations))
# 
# names(old_sf)[27]
# names(old_sf) == names(sf)
# old_sf <- sf::st_transform(old_sf, st_crs(sf))
# new <- rbind(sf,old_sf)
# plot(new$geom)
# st_write(new, 'E:/updated_crowns_bouamir.gpkg')
```

